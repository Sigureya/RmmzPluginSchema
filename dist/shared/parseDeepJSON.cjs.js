"use strict";const m=r=>r.kind.endsWith("[]"),O=r=>m(r.attr),b=r=>r.kind!=="struct"&&!m(r),l=r=>r.kind==="struct",P=r=>r.kind==="struct[]",j=r=>r.attr.kind==="struct[]",o=r=>{var t;return((t=c[r.attr.kind])==null?void 0:t.hasText)===!0},k=r=>b(r)&&T(r),T=r=>c[r.kind].type==="number",g=r=>c[r.kind.replace("[]","")].type==="number",n={type:"string",hasText:!0},s={type:"number",hasText:!1},e={type:"number",hasText:!1},c={string:n,number:{type:"number",hasText:!1},boolean:{type:"boolean"},armor:s,actor:s,class:s,enemy:s,skill:s,state:s,item:s,weapon:s,common_event:s,switch:s,variable:s,troop:s,multiline_string:n,file:{type:"string",hasText:!1},"file[]":{type:"string",hasText:!1},"multiline_string[]":n,"string[]":n,combo:n,select:n,any:n,struct:{type:"struct"},"actor[]":e,"enemy[]":e,"class[]":e,"skill[]":e,"state[]":e,"item[]":e,"weapon[]":e,"common_event[]":e,"troop[]":e,"armor[]":e,"switch[]":e,"variable[]":e,"number[]":e},x=r=>d(r,t=>!0,t=>!0),d=(r,t,a)=>{const u=[],f=[],h=[],A=[];return r.forEach(i=>{if(l(i.attr))u.push({name:i.name,attr:i.attr});else if(j(i))f.push(i);else if(O(i)){if(a(i))return void A.push(i)}else t(i)&&h.push(i)}),{structs:u,structArrays:f,scalars:h,scalarArrays:A}};function y(r){const t=r.map(a=>[a.name,a.attr]);return Object.fromEntries(t)}const v=r=>({...r.text?{text:r.text}:{},...r.desc?{desc:r.desc}:{}}),S=r=>Object.fromEntries(Object.entries(r).map(([t,a])=>[t,p(a)])),p=r=>{if(typeof r!="string")return r;try{const t=JSON.parse(r);return Array.isArray(t)?t.map(p):typeof t=="object"&&t!==null?Object.fromEntries(Object.entries(t).map(([a,u])=>[a,p(u)])):t}catch{return r}};exports.classifyFileParams=r=>d(r,t=>t.attr.kind==="file",t=>t.attr.kind==="file[]"),exports.classifyPluginParams=x,exports.classifyTextParams=r=>d(r,t=>o(t),t=>o(t)),exports.convertPluginCommandSchema=r=>({...v(r),command:r.command,args:y(r.args)}),exports.convertStructSchema=r=>({struct:r.struct,params:y(r.params)}),exports.createClassifiedStructMap=r=>new Map(r.map(t=>[t.struct,x(t.params)])),exports.createStructMap=r=>new Map(r.map(t=>[t.struct,t.params.map(a=>a.attr)])),exports.hasNumberValueParam=r=>m(r)?g(r):k(r),exports.hasScalarAttr=r=>b(r.attr),exports.hasStructAttr=r=>l(r.attr)||P(r.attr),exports.hasTextAttr=o,exports.isArrayAttr=O,exports.isArrayParam=m,exports.isArrayParamEx=(r,t)=>!!m(r)&&r.kind===`${t}[]`,exports.isFileAttr=r=>r.attr.kind==="file"||r.attr.kind==="file[]",exports.isNumberArrayParam=g,exports.isNumberAttr=r=>{var t;return((t=c[r.attr.kind])==null?void 0:t.type)==="number"},exports.isNumberValueParam=k,exports.isNumberValueParamEx=T,exports.isScalarParam=b,exports.isStringArrayParam=r=>c[r.kind.replace("[]","")].type==="string",exports.isStringValueParam=r=>c[r.kind].type==="string",exports.isStructArrayAttr=j,exports.isStructArrayParam=P,exports.isStructAttr=r=>l(r.attr),exports.isStructParam=l,exports.isVariableAttr=r=>r.attr.kind==="variable"||r.attr.kind==="variable[]",exports.paramHasText=r=>{var t;return((t=c[r.kind])==null?void 0:t.hasText)===!0},exports.parseDeepJSON=r=>{const t=JSON.parse(r);return Array.isArray(t)?t.map(p):typeof t=="object"&&t!==null?S(t):t},exports.parseDeepRecord=r=>S(r),exports.toArrayPluginParam=r=>Object.entries(r).map(([t,a])=>({name:t,attr:a})),exports.toObjectPluginParams=function(r){const t=r.map(a=>[a.name,a.attr]);return Object.fromEntries(t)},exports.toObjectPluginParamsOld=y;
