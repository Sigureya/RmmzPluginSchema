"use strict";const m=t=>t.kind.endsWith("[]"),O=t=>m(t.attr),b=t=>t.kind!=="struct"&&!m(t),l=t=>t.kind==="struct",P=t=>t.kind==="struct[]",j=t=>t.attr.kind==="struct[]",p=t=>{var r;return((r=c[t.attr.kind])==null?void 0:r.hasText)===!0},k=t=>b(t)&&T(t),T=t=>c[t.kind].type==="number",g=t=>c[t.kind.replace("[]","")].type==="number",i={type:"string",hasText:!0},s={type:"number",hasText:!1},e={type:"number",hasText:!1},c={string:i,number:{type:"number",hasText:!1},boolean:{type:"boolean"},armor:s,actor:s,class:s,enemy:s,skill:s,state:s,item:s,weapon:s,common_event:s,switch:s,variable:s,troop:s,multiline_string:i,file:{type:"string",hasText:!1},"file[]":{type:"string",hasText:!1},"multiline_string[]":i,"string[]":i,combo:i,select:i,any:i,struct:{type:"struct"},"actor[]":e,"enemy[]":e,"class[]":e,"skill[]":e,"state[]":e,"item[]":e,"weapon[]":e,"common_event[]":e,"troop[]":e,"armor[]":e,"switch[]":e,"variable[]":e,"number[]":e};function x(t){return d(t,r=>!0,r=>!0)}const d=(t,r,a)=>{const u=[],f=[],h=[],A=[];return t.forEach(n=>{if(l(n.attr))u.push({name:n.name,attr:n.attr});else if(j(n))f.push(n);else if(O(n)){if(a(n))return void A.push(n)}else r(n)&&h.push(n)}),{structs:u,structArrays:f,scalars:h,scalarArrays:A}};function y(t){const r=t.map(a=>[a.name,a.attr]);return Object.fromEntries(r)}const v=t=>({...t.text?{text:t.text}:{},...t.desc?{desc:t.desc}:{}}),S=t=>Object.fromEntries(Object.entries(t).map(([r,a])=>[r,o(a)])),o=t=>{if(typeof t!="string")return t;try{const r=JSON.parse(t);return Array.isArray(r)?r.map(o):typeof r=="object"&&r!==null?Object.fromEntries(Object.entries(r).map(([a,u])=>[a,o(u)])):r}catch{return t}};exports.classifyFileParams=t=>d(t,r=>r.attr.kind==="file",r=>r.attr.kind==="file[]"),exports.classifyPluginParams=x,exports.classifyTextParams=t=>d(t,r=>p(r),r=>p(r)),exports.convertPluginCommandSchema=t=>({...v(t),command:t.command,args:y(t.args)}),exports.convertStructSchema=t=>({struct:t.struct,params:y(t.params)}),exports.createClassifiedStructMap=t=>new Map(t.map(r=>[r.struct,x(r.params)])),exports.createStructMap=t=>new Map(t.map(r=>[r.struct,r.params.map(a=>a.attr)])),exports.hasNumberValueParam=t=>m(t)?g(t):k(t),exports.hasScalarAttr=t=>b(t.attr),exports.hasStructAttr=t=>l(t.attr)||P(t.attr),exports.hasTextAttr=p,exports.isArrayAttr=O,exports.isArrayParam=m,exports.isArrayParamEx=(t,r)=>!!m(t)&&t.kind===`${r}[]`,exports.isFileAttr=t=>t.attr.kind==="file"||t.attr.kind==="file[]",exports.isNumberArrayParam=g,exports.isNumberAttr=t=>{var r;return((r=c[t.attr.kind])==null?void 0:r.type)==="number"},exports.isNumberValueParam=k,exports.isNumberValueParamEx=T,exports.isScalarParam=b,exports.isStringArrayParam=t=>c[t.kind.replace("[]","")].type==="string",exports.isStringValueParam=t=>c[t.kind].type==="string",exports.isStructArrayAttr=j,exports.isStructArrayParam=P,exports.isStructAttr=t=>l(t.attr),exports.isStructParam=l,exports.isVariableAttr=t=>t.attr.kind==="variable"||t.attr.kind==="variable[]",exports.paramHasText=t=>{var r;return((r=c[t.kind])==null?void 0:r.hasText)===!0},exports.parseDeepJSON=t=>{const r=JSON.parse(t);return Array.isArray(r)?r.map(o):typeof r=="object"&&r!==null?S(r):r},exports.parseDeepRecord=t=>S(t),exports.toArrayPluginParam=t=>Object.entries(t).map(([r,a])=>({name:r,attr:a})),exports.toObjectPluginParams=function(t){const r=t.map(a=>[a.name,a.attr]);return Object.fromEntries(r)},exports.toObjectPluginParamsOld=y;
