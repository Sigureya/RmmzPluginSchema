"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const u=require("../shared/structMap.cjs.js"),F=(a,r)=>{if(a.length!==0)return`${r}[${a.map(t=>`"${t.name}"`).join(",")}]`},J=(a,r)=>a.map(t=>({path:`${r}.${t.name}[*]`,param:t})),P={undefinedStruct:"undefined_struct",cyclicStruct:"cyclic_struct"};function q(a,{path:r,structName:t}){return{category:"struct",objectSchema:u.toObjectPluginParams(a.scalars),name:t,scalarArrays:J(a.scalarArrays,r),scalarsPath:a.scalars.length>0?F(a.scalars,r):void 0}}function N(a,r,t,e){const m={items:[],errs:[],frames:[{schemaName:a,basePath:r,ancestry:[]}]},s=Math.max(1,3*t.size+5),o=Array.from({length:s}).reduce(i=>i.frames.length===0?i:function(c,g,$){if(c.frames.length===0)return c;const n=c.frames[c.frames.length-1],l=c.frames.slice(0,-1);if(n.ancestry.includes(n.schemaName))return{frames:l,items:c.items,errs:[...c.errs,{code:$.cyclicStruct,path:n.basePath}]};const p=g.get(n.schemaName);if(!p)return{frames:l,items:c.items,errs:[...c.errs,{code:$.undefinedStruct,path:n.basePath}]};const b=function(h,C){const v=h.ancestry.concat(h.schemaName),j=h.basePath;return[...C.structs.map(y=>({schemaName:y.attr.struct,basePath:`${j}.${y.name}`,ancestry:v})),...C.structArrays.map(y=>({schemaName:y.attr.struct,basePath:`${j}.${y.name}[*]`,ancestry:v}))].reverse()}(n,p);if(p.scalars.length>0||p.scalarArrays.length>0){const h=q(p,{path:n.basePath,structName:n.schemaName});return l.push(...b),{frames:l,items:[...c.items,h],errs:c.errs}}return l.push(...b),{frames:l,items:c.items,errs:c.errs}}(i,t,e),m);return{items:o.items,errors:o.errs}}const k=(a,r,t,e=P)=>{const m=a.map(s=>N(s.attr.struct,`${r}.${s.name}`,t,e));return{items:m.flatMap(s=>s.items),errors:m.flatMap(s=>s.errors)}},E=(a,r,t,e=P)=>{const m=a.map(s=>N(s.attr.struct,`${r}.${s.name}[*]`,t,e));return{items:m.flatMap(s=>s.items),errors:m.flatMap(s=>s.errors)}},A=(a,r,t,e)=>u.isStructAttr(t)?O(a,t,e):u.isStructArrayAttr(t)?z(a,t,e):u.isArrayAttr(t)?w(a,r,t):V(a,r,t),w=(a,r,t)=>({rootCategory:a,rootName:r,scalars:{category:a,name:"array",objectSchema:{},scalarsPath:void 0,scalarArrays:[{path:`$.${t.name}[*]`,param:t}]},structs:{items:[],errors:[]},structArrays:{items:[],errors:[]}}),V=(a,r,t)=>({rootCategory:a,rootName:r,scalars:{category:"primitive",name:t.attr.kind,objectSchema:{[t.name]:t.attr},scalarsPath:`$.${t.name}`,scalarArrays:[]},structArrays:{items:[],errors:[]},structs:{items:[],errors:[]}}),O=(a,r,t)=>({rootName:r.name,rootCategory:a,scalars:void 0,structArrays:{items:[],errors:[]},structs:k([r],"$",t)}),z=(a,r,t)=>({structArrays:E([r],"$",t),rootName:r.name,rootCategory:a,scalars:void 0,structs:{items:[],errors:[]}}),B=(a,r)=>r.map(t=>K(a,t)).flat(3),K=(a,r)=>[r.top?f(r,a,r.top):[],r.structs.map(t=>f(r,a,t)),r.structArrays.map(t=>f(r,a,t))],f=(a,r,t)=>{const e=t.bundleName;return[t.scalar?D(a,e,r,t.scalar.jsonPathJS,t.scalar.record):[],t.arrays.map(m=>G(a,e,r,m))].flat(2)},D=(a,r,t,e,m)=>e.pathSegments(t).reduce((s,{value:o,segments:i})=>{if(typeof o=="object")return s;const c=i[i.length-1];if(typeof c=="number")return s;const g=m[c];return g&&s.push({roootName:a.rootName,rootType:a.rootCategory,category:"struct",name:r,value:o,param:{name:c,attr:g}}),s},[]),G=(a,r,t,e)=>{const m=e.jsonPathJS.find(t);if(!Array.isArray(m))return[];const s=e.schema.attr;return u.isStringArrayParam(s)?m.filter(o=>typeof o=="string").map(o=>({value:o,category:"struct",rootType:a.rootCategory,roootName:a.rootName,name:r,param:e.schema})):u.isNumberArrayParam(s)?m.filter(o=>typeof o=="number").map(o=>({roootName:a.rootName,rootType:a.rootCategory,value:o,category:"struct",name:r,param:e.schema})):[]},_=(a,r)=>{const t=a.scalars?d(a.scalars,r):void 0,e=a.structs.items.map(s=>d(s,r)),m=a.structArrays.items.map(s=>d(s,r));return{rootCategory:a.rootCategory,rootName:a.rootName,top:t,structs:e,structArrays:m}},d=(a,r)=>a.scalarsPath?{bundleName:a.name,arrays:x(a.scalarArrays,a.name,r),scalar:H(a.scalarsPath,a.objectSchema,r)}:{bundleName:a.name,arrays:x(a.scalarArrays,a.name,r)},x=(a,r,t)=>a.map(e=>({jsonPathJS:t(e.path),schema:e.param,parentType:r})),H=(a,r,t)=>({jsonPathJS:t(a),record:r}),S=(a,r,t,e)=>({pluginName:a,commandName:r.command,desc:r.desc??"",text:r.text??"",extractors:I(r,t,e)}),I=(a,r,t)=>a.args.map(e=>{const m=A("args",a.command,e,r);return _(m,t)}),M=(a,r)=>({pluginName:r.pluginName,commandName:r.commandName,args:B(a,r.extractors)}),T=(a,r)=>{const t=u.createClassifiedStructMap(a.schema.structs);return a.schema.commands.map(e=>[`${a.pluginName}:${e.command}`,S(a.pluginName,e,t,r)])},L=(a,r,t)=>a.params.map(e=>{const m=A("param",e.name,e,r);return _(m,t)}),Q=(a,r,t,e)=>r.map(m=>[`${a}:${m.command}`,S(a,m,t,e)]);exports.compileCommandExtractorsFromPlugins=(a,r)=>new Map(a.flatMap(t=>T(t,r))),exports.compilePluginCommandExtractor=S,exports.compilePluginCommandPairs=T,exports.createPluginValueExtractor=(a,r,t)=>{const e=u.createClassifiedStructMap(r.structs);return{params:L(r,e,t),commands:Q(a,r.commands,e,t)}},exports.createPluginValuesPath=A,exports.createPrimiteveParamPath=V,exports.createStructParamPath=(a,r,t)=>O(a,r,t),exports.extractCommandArgsByKey=(a,r,t)=>{const e=t.get(r);if(e)return M(a,e)},exports.extractPluginCommandArgs=M,exports.getPathFromStructArraySchema=E,exports.getPathFromStructParam=k,exports.getPathFromStructSchema=(a,r,t,e=P)=>N(a,r,t,e),exports.makeScalarArrayPath=J,exports.makeScalarValuesPath=F;
