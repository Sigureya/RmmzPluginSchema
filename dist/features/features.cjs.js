"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const l=require("../shared/parseDeepJSON.cjs.js"),j=(a,r)=>{if(a.length!==0)return`${r}[${a.map(t=>`"${t.name}"`).join(",")}]`},M=(a,r)=>a.map(t=>({path:`${r}["${t.name}"][*]`,param:t})),P={undefinedStruct:"undefined_struct",cyclicStruct:"cyclic_struct"};function k(a,r,t){if(a.frames.length===0)return a;const e=a.frames[a.frames.length-1],s=a.frames.slice(0,-1);if(e.ancestry.includes(e.schemaName))return{frames:s,items:a.items,errs:[...a.errs,{code:t.cyclicStruct,path:e.basePath}]};const m=r.get(e.schemaName);if(!m)return{frames:s,items:a.items,errs:[...a.errs,{code:t.undefinedStruct,path:e.basePath}]};const o=function(c,u){const p=c.ancestry.concat(c.schemaName),i=c.basePath;return[...u.structs.map(n=>({schemaName:n.attr.struct,basePath:`${i}["${n.name}"]`,ancestry:p})),...u.structArrays.map(n=>({schemaName:n.attr.struct,basePath:`${i}["${n.name}"][*]`,ancestry:p}))].reverse()}(e,m);if(m.scalars.length>0||m.scalarArrays.length>0){const c=function(u,{path:p,structName:i}){return{category:"struct",objectSchema:l.toObjectPluginParams(u.scalars),name:i,scalarArrays:M(u.scalarArrays,p),scalarsPath:u.scalars.length>0?j(u.scalars,p):void 0}}(m,{path:e.basePath,structName:e.schemaName});return s.push(...o),{frames:s,items:[...a.items,c],errs:a.errs}}return s.push(...o),{frames:s,items:a.items,errs:a.errs}}function N(a,r,t,e){const s={items:[],errs:[],frames:[{schemaName:a,basePath:r,ancestry:[]}]},m=Math.max(1,3*t.size+5),o=Array.from({length:m}).reduce(c=>c.frames.length===0?c:k(c,t,e),s);return{items:o.items,errors:o.errs}}const E=(a,r,t,e=P)=>N(a.attr.struct,`${r}["${a.name}"]`,t,e),T=(a,r,t,e=P)=>N(a.attr.struct,`${r}["${a.name}"][*]`,t,e),g=(a,r,t,e)=>l.isStructAttr(t)?V(a,t,e):l.isStructArrayAttr(t)?O(a,t,e):l.isArrayAttr(t)?w(a,r,t):F(a,r,t),w=(a,r,t)=>({rootCategory:a,rootName:r,scalars:{name:"",objectSchema:{},scalarsPath:void 0,scalarArrays:[{path:`$["${t.name}"][*]`,param:t}]},structs:{items:[],errors:[]},structArrays:{items:[],errors:[]}}),F=(a,r,t)=>({rootCategory:a,rootName:r,scalars:{name:t.attr.kind,objectSchema:{[t.name]:t.attr},scalarsPath:`$["${t.name}"]`,scalarArrays:[]},structArrays:{items:[],errors:[]},structs:{items:[],errors:[]}}),V=(a,r,t)=>({rootName:r.name,rootCategory:a,scalars:void 0,structArrays:{items:[],errors:[]},structs:E(r,"$",t)}),O=(a,r,t)=>({structArrays:T(r,"$",t),rootName:r.name,rootCategory:a,scalars:void 0,structs:{items:[],errors:[]}}),R=(a,r,t,e)=>r.filter(s=>typeof s=="number").map(s=>({rootName:a.rootName,rootType:a.rootCategory,value:s,structName:t,param:e})),_=(a,r,t,e)=>r.filter(s=>typeof s=="string").map(s=>({rootName:a.rootName,rootType:a.rootCategory,value:s,structName:t,param:e})),q=(a,r,t,e,s)=>{if(typeof t=="object"||t===null)return null;const m=e[e.length-1];if(typeof m=="number")return null;const o=s[m];return o?{rootName:a.rootName,rootType:a.rootCategory,structName:r,value:t,param:{name:m,attr:o}}:null},f=(a,r)=>r.map(t=>z(a,t)).flat(3),z=(a,r)=>[r.top?y(r,a,r.top,""):[],r.structs.map(t=>y(r,a,t)),r.structArrays.map(t=>y(r,a,t))],y=(a,r,t,e=t.bundleName)=>{const s=t.scalar?((o,c,u,p,i)=>p.pathSegments(u).map(({value:n,segments:h})=>q(o,c,n,h,i)).filter(n=>n!==null))(a,e,r,t.scalar.jsonPathJS,t.scalar.record):[],m=t.arrays.map(o=>((c,u,p,i)=>{const n=i.jsonPathJS.find(p);if(!Array.isArray(n))return[];const h=i.schema.attr;return l.isStringArrayParam(h)?_(c,n,u,i.schema):l.isNumberArrayParam(h)?R(c,n,u,i.schema):[]})(a,e,r,o));return[s,m].flat(2)},A=(a,r)=>{const t=a.scalars?d(a.scalars,r):void 0,e=a.structs.items.map(m=>d(m,r)),s=a.structArrays.items.map(m=>d(m,r));return{rootCategory:a.rootCategory,rootName:a.rootName,top:t,structs:e,structArrays:s}},d=(a,r)=>a.scalarsPath?{bundleName:a.name,arrays:$(a.scalarArrays,a.name,r),scalar:B(a.scalarsPath,a.objectSchema,r)}:{bundleName:a.name,arrays:$(a.scalarArrays,a.name,r)},$=(a,r,t)=>a.map(e=>({jsonPathJS:t(e.path),schema:e.param,parentType:r})),B=(a,r,t)=>({jsonPathJS:t(a),record:r}),S=(a,r,t,e)=>({pluginName:a,commandName:r.command,desc:r.desc??"",text:r.text??"",extractors:D(r,t,e)}),D=(a,r,t)=>a.args.map(e=>{const s=g("args",a.command,e,r);return A(s,t)}),b=(a,r)=>({pluginName:r.pluginName,commandName:r.commandName,args:f(a,r.extractors)}),C=(a,r)=>{const t=l.createClassifiedStructMap(a.schema.structs);return a.schema.commands.map(e=>[`${a.pluginName}:${e.command}`,S(a.pluginName,e,t,r)])},x=(a,r)=>{const t=l.parseDeepRecord(a.parameters);return{pluginName:a.name,params:f(t,r)}},v=(a,r,t)=>{const e=l.createClassifiedStructMap(r.structs);return{pluginName:a,params:K(r,e,t),commands:J(a,r.commands,e,t)}},K=(a,r,t)=>a.params.map(e=>{const s=g("param",e.name,e,r);return A(s,t)}),J=(a,r,t,e)=>r.map(s=>[`${a}:${s.command}`,S(a,s,t,e)]);exports.compileCommandExtractorsFromPlugins=(a,r)=>new Map(a.flatMap(t=>C(t,r))),exports.compilePluginCommandExtractor=S,exports.compilePluginCommandPairs=C,exports.compilePluginParamExtractor=(a,r,t)=>({pluginName:a.pluginName,extractors:a.schema.params.map(e=>{const s=g("param","plugin",e,r);return A(s,t)})}),exports.convertPlugin=(a,r,t)=>{const e=v(a.pluginName,a.schema,t),{params:s}=x(r,e.params);return{record:r,schema:a,extractorEntries:e.commands,params:s}},exports.createPluginCommandExtractor=(a,r)=>{const t=l.createClassifiedStructMap(a.schema.structs);return J(a.pluginName,a.schema.commands,t,r)},exports.createPluginValueExtractor=v,exports.createPluginValuesPath=g,exports.createPrimiteveParamPath=F,exports.createStructParamPath=(a,r,t)=>V(a,r,t),exports.extractCommandArgsByKey=(a,r,t)=>{const e=t.get(r);if(e)return b(a,e)},exports.extractPluginCommandArgs=b,exports.extractPluginParam=(a,r)=>({pluginName:r.pluginName,params:f(a,r.extractors)}),exports.extractPluginParamFromRecord=x,exports.getPathFromStructArraySchema=T,exports.getPathFromStructParam=E,exports.getPathFromStructSchema=(a,r,t,e=P)=>N(a,r,t,e),exports.isCommandArgValue=a=>a.rootType==="args",exports.ispluginParamValue=a=>a.rootType==="param",exports.makeScalarArrayPath=M,exports.makeScalarValuesPath=j,exports.mergeCommandMap=a=>{const r=a.flatMap(t=>t.extractorEntries);return new Map(r)};
